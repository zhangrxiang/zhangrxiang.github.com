# PHP

## 理论知识
### 常用的超全局变量(8个)
- `$_GET` ----->get传送方式
- `$_POST` ----->post传送方式
- `$_REQUEST` ----->可以接收到get和post两种方式的值
- `$GLOBALS` ----->所有的变量都放在里面
- `$_FILE` ----->上传文件使用
- `$_SERVER` ----->系统环境变量
- `$_SESSION` ----->会话控制的时候会用到
- `$_COOKIE` ----->会话控制的时候会用到

### `$_POST`，`$HTTP_RAW_POST_DATA` 和 `php://input` 的区别？
#### `$_POST`
是获取表单`POST`过来数据，`MIME`类型是`“application/x-www-form-urlencoded”`。可参考`《什么是MIME TYPE》`
意思就是字段名和值都编码了，每个 `key-value` 对使用 `‘&’` 字符分隔开，`key` 和 `value` 使用 `‘=’` 分开，其他特殊字符都会被使用 `urlencode` 方式进行编码。
#### `$HTTP_RAW_POST_DATA`
可以获取原始的`POST`数据，但需要在 `php.ini` 中设置开启，并且不支持 `enctype="multipart/form-data"`方式传递的数据
#### `php://input`
可以获取原始的 `POST` 数据，并且比`$HTTP_RAW_POST_DATA`更少消耗内存，也不支持`"multipart/form-data"`，可以使用 `file_get_contents()` 函数去获取它的内容

### 介绍一下常见的`SSO`(`单点登陆`)的原理。
`SSO`是**一种统一认证和授权机制**，通过一个应用中的安全验证后，再访问其他应用中的受保护资源时，不再需要重新登录验证。解决了用户只需要登录一次就可以访问所有相互信任的应用系统，而不用重复登录。统一的认证系统是`SSO`的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；认证成功后，认证系统应该生成统一的认证标志（`ticket`），返还给用户。另外，认证系统还应该对ticket进行效验，判断其有效性。

### PHP缓存技术有哪些? 
#### 全页面静态化缓存
也就是将页面全部生成`html`静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程。此种方式，在`CMS`系统中比较常见，比如dedecms；一种比较常用的实现方式是用输出缓存：
```php
ob_start()
******要运行的代码*******
$content = ob_get_contents();
****将缓存内容写入html文件*****
ob_end_clean();
```
#### 页面部分缓存
该种方式，是将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于`ob_get_contents`的方式实现，也可以利用类似`ESI`之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存(ESI技术，请baidu，此处不详讲)。该种方式可以用于如商城中的商品页；
#### 数据缓存
顾名思义，就是缓存数据的一种方式；比如，商城中的某个商品信息，当用商品id去请求时，就会得出包括店铺信息、商品信息等数据，此时就可以将这些数据缓存到一个php文件中，文件名包含商品id来建一个唯一标示；下一次有人想查看这个商品时，首先就直接调这个文件里面的信息，而不用再去数据库查询；其实缓存文件中缓存的就是一个php数组之类；Ecmall商城系统里面就用了这种方式；
#### 查询缓存
其实这跟数据缓存是一个思路，就是根据查询语句来缓存；将查询得到的数据缓存在一个文件中，下次遇到相同的查询时，就直接先从这个文件里面调数据，不会再去查数据库；但此处的缓存文件名可能就需要以查询语句为基点来建立唯一标示；按时间变更进行缓存。其实，这一条不是真正的缓存方式；上面的2、3、4的缓存技术一般都用到了时间变更判断；就是对于缓存文件您需要设一个有效时间，在这个有效时间内，相同的访问才会先取缓存文件的内容，但是超过设定的缓存时间，就需要重新从数据库中获取数据，并生产最新的缓存文件；比如，我将我们商城的首页就是设置2个小时更新一次。
#### 按内容变更进行缓存
这个也并非独立的缓存技术，需结合着用；就是当数据库内容被修改时，即刻更新缓存文件；比如，一个人流量很大的商城，商品很多，商品表必然比较大，这表的压力也比较重；我们就可以对商品显示页进行页面缓存；当商家在后台修改这个商品的信息时，点击保存，我们同时就更新缓存文件；那么，买家访问这个商品信息时，实际上访问的是一个静态页面，而不需要再去访问数据库；试想，如果对商品页不缓存，那么每次访问一个商品就要去数据库查一次，如果有10万人在线浏览商品，那服务器压力就大了；
#### 内存式缓存
提到这个，可能大家想到的首先就是`Memcached`；`memcached`是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。它就是将需要缓存的信息，缓存到系统内存中，需要获取信息时，直接到内存中取；比较常用的方式就是 `key–>value`方式；
```php
<?php 
     $memcachehost = '192.168.6.191';
     $memcacheport = 11211;
     $memcachelife = 60;
     $memcache = new Memcache;
     $memcache->connect($memcachehost,$memcacheport) or die ("Could not connect");
     $memcache->set('key','缓存的内容');
     $get = $memcache->get($key);       //获取信息
```
### `apache`缓存模块
`apache`安装完以后，是不允许被`cache`的。如果外接了`cache`或`squid`服务器要求进行web加速的话，就需要在`httpd.conf`里进行设置，当然前提是在安装`apache`的时候要激活`mod_cache`的模块。安装apache时：`./configure –enable-cache –enable-disk-cache –enable-mem-cache`
#### `php APC`缓存扩展
PHP有一个`APC`缓存扩展，windows下面为`php_apc.dll`，需要先加载这个模块，然后是在`php.ini`里面进行配置：
```ini
[apc] 
     extension=php_apc.dll 
     apc.rfc1867 = on 
     upload_max_filesize = 100M 
     post_max_size = 100M 
     apc.max_file_size = 200M 
     upload_max_filesize = 1000M 
     post_max_size = 1000M 
     max_execution_time = 600 ;   每个PHP页面运行的最大时间值(秒)，默认30秒 
     max_input_time = 600 ;       每个PHP页面接收数据所需的最大时间，默认60 
     memory_limit = 128M ;       每个PHP页面所吃掉的最大内存，默认8M
```
#### `Opcode`缓存
首先`php`代码被解析为`Tokens`，然后再编译为`Opcode`码，最后执行`Opcode`码，返回结果；所以，对于相同的`php`文件，第一次运行时可以缓存其`Opcode`码，下次再执行这个页面时，直接会去找到缓存下的`opcode`码，直接执行最后一步，而不再需要中间的步骤了。比较知名的是`XCache`、`Turck MM Cache`、`PHP Accelerator`等。

### php中传值与传引用的区别
- 按值传递：函数范围内对值的任何改变在函数外部都会被忽略
- 引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

### PHP的垃圾收集机制是怎样的？
PHP是一门`托管型`语言，在PHP编程中程序员不需要手工处理内存资源的分配与释放，这就意味着PHP本身实现了`垃圾回收机制`（`Garbage Collection`）PHP使用的回收算法是**引用计数法**，每个php变量存在一个叫`"zval"`的变量容器。一个`zval`变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是`"is_ref"`，是个`bool`值，用来标识这个变量是否是属于引用集合`(reference set)`。第二个额外字节是`"refcount"`，用以表示指向这个`zval`变量容器的变量(也称符号即`symbol`)个数。把一个变量赋值给另一变量将增加引用次数(`refcount`)
当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数`unset()`时，`"refcount"`就会减1变量容器在`"refcount"`变成0时就被销毁

### 说几个你知道的设计模式？
#### 单例模式：
保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接
#### 简单工厂模式：
它具有创建对象的某些方法，可以使用工厂类创建对象，而不直接使用 `new`。例如初始化数据库的时候会用到，比如`MySQL`，`MSSQL`
#### 策略模式：
针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作
#### 注册模式：
提供了在程序中有条理的存放并管理一组全局对象 (`object`)，例如`ZF`框架中的`Zend_Registry::set`
#### 适配器模式：
将不同接口适配成统一的`API`接口，例如数据操作有`mysql`、`mysqli`、`pdo`等，可利用适配器模式统一接口
#### 观察者模式：
一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送
#### 装饰器模式：
不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个`Controller`文件会提供`before`和`after`方法
#### 迭代器模式：
提供一个方法顺序访问一个聚合对象中各个元素，在PHP中将继承`Iterator`类
#### 原型模式：
实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。

### `isset`、`empty`、`is_null`的区别
#### `isset` 
判断变量是否定义或者是否为空
- 变量存在返回`ture`，否则返回`false`
- 变量定义不赋值返回`false`
- `unset`一个变量，返回`false`
- 变量赋值为`null`，返回`false`

#### `empty`
判断变量的值是否为空，能转换为`false`的都是空，为空返回`true`，反之返回`false`。
- `""`,`0`,`"0"`,`NULL`，`FALSE`都认为为空，返回`true` 
- 没有任何属性的对象都认为是空
    
#### `is_null`
检测传入的值(值、变量、表达式)是否为`null`
- 定义了，但是赋值为`null`
- 定义了，但是没有赋值
- `unset`一个变量

### 框架中什么是单一入口和多入口 ， 单一入口的优缺点？
多入口就是通过访问不同的文件来完成用户请求。单一入口只 `web` 程序所有的请求都指向一个脚本文件的。单一入口更容易控制权限，方便对 `http` 请求可以进行安全性检查。缺点：`URL` 看起来不那么美观，特别是对搜索引擎来说不友好。

### 简述两种屏蔽php程序的`notice`警告的方法
初始化变量，文件开始设置错误级别或者修改`php.ini` 设置`error_reporting` 
`set_error_handler` 和 `@抑制错误` 
1. 在程序中添加：`error_reporting (E_ALL & ~E_NOTICE)`; 
2. 或者修改`php.ini`中的：`error_reporting = E_ALL` 改为：`error_reporting = E_ALL & ~E_NOTICE`
3. `error_reporting(0)`;或者修改`php.ini` `display_errors=Off`

### PHP配置指令作用域说明
PHP总共有4个配置指令作用域：（PHP中的每个指令都有自己的作用域，指令只能在其作用域中修改，不是任何地方都能修改配置指令的）
- `PHP_INI_PERDIR`：指令可以在`php.ini`、`httpd.conf`或`.htaccess`文件中修改
- `PHP_INI_SYSTEM`：指令可以在`php.ini` 和 `httpd.conf`文件中修改
- `PHP_INI_USER`：指令可以在用户脚本中修改
- `PHP_INI_ALL`：指令可以在任何地方修改

# 面向对象

## 面向对象基础
### 面向对象
#### 什么是类？
具有相同属性（特征）和方法（行为）的一系列个体的集合，类是一个抽象的概念。

#### 什么是对象？
从类中，拿到的具有具体属性值的个体，称为对象。对象是一个具体的个体。
eg:人类；张三

#### 类和对象的关系？
- **类是对象的抽象化！对象是类的具体化！**
- 类仅仅表明这类对象有哪些属性，但是不能有具体的值，所以类是抽象的。
- 对象是将类的所有属性赋值后，产生具体的个体，所有对象是具体的。

### 类的声明与实例化
#### 如何声明一个类：
```php
class 类名{
    访问修饰符 $属性[=默认值];
    [访问修饰符] function 方法(){}
}
```
```php
class SimpleClass {
	// property declaration
	public $var = 'a default value';

	// method declaration
	public function displayVar() {
		echo $this->var;
	}
}
```
#### 声明一个类的注意事项：
- 类名只能有字母数字下划线组成，开头不能是数字，必须符合大驼峰法则;
- 类名必须使用`class`修饰，类名后面一定不能有();
- 属性必须要带访问修饰符，方法可以不带访问修饰符。

#### 实例化对象及对象属性方法的调用：
`$对象名 = new 类名(); //()可以不带`

#### 类外部调用属性和方法：
`$对象名 -> $属性名; //使用->调用属性时，属性名不能带$符号`

#### 类内部调用属性和方法：
`$this -> $属性名;`

### 构造函数
#### 什么是构造函数？
构造函数是类中的一个特殊函数，当我们使用new关键字实例化对象时，相当于调用了类的构造函数。

#### 构造函数有什么作用？
实例化对象时，自动调用，用于给对象的属性赋初值！

#### 构造函数的写法：
- 构造函数名，必须与类同名(废弃)
```php
[public] function Person($name){
    $this -> name = $name;
}
```
- 使用魔术方法`__construct`
```php
[public] function __construct($name){
    $this -> name = $name;
}
```

#### 构造函数注意事项：
- 第一种写法，构造函数名必须与类同名！！！！
- 如果一个类没有手写构造函数，则系统默认会有一个空参构造，因此可以使用`new Person()`;
- 如果我们写了带参数的构造函数，则将不会再有空参构造，也就是不能直接使用`new Person()`;
- `Person`后面的`()`中的参数列表，必须符合构造函数的要求！！！！
- 如果两种构造函数同时存在，将使用`__construct`。

#### 析构函数：`__destruct()`:
- 析构函数在对象被销毁释放之前自动调用；
- 析构函数不能带有任何的参数；
- 析构函数常用于对象使用完以后，释放资源，关闭资源等。

#### 魔术方法：
PHP中，给我们提供一系列用`__`开头的函数，这些函数无需自己手动调用，
会在合适的时机自动调用，这类函数称为魔术称为魔术函数。
eg:`function __construct(){}` 在类new一个对象时自动调用
`function __destruct(){}` 在对象被销毁时自动调用,我们要求，除了魔术方法之外，自定义的函数与方法不能使用`__`开头。最后，一般对于功能比较复杂的类，我们会单独的写到一个类文件中。类文件的命名，同一小写，使用`"类名小写.class.php"`的方式命名。在其他文件中使用这个类时，可以使用include导入这个`".class.php"`文件。

## 封装和继承
### 什么是封装？
通过访问修饰符，将类中不需要外部访问的属性和方法进行私有化处理，以实现访问控制。
> 注意：是实现访问控制，而不是拒绝访问。也就是说，我们私有化属性后，需要提供对应的方法，让用户通过我们提供的方法处理属性。

### 封装的作用？
- 使用者只关心类能够提供的功能，不关心功能实现的细节！（封装方法）
- 对用户的数据进行控制，防止设置不合法数据，控制返回给用户的数据（属性封装+`set/get`方法）

### 实现封装操作？
#### 方法的封装
对于一些只在类内部使用的方法，而不像对外部提供使用，那么，这样的方法我们可以使用private进行私有化处理。
```php
private function formatName(){} //这个方法仅仅能在类内部使用$this调用
function showName(){
    $this->formatName();
}
```
#### 属性的封装+`set/get`方法
为了控制属性的设置以及读取，可以将属性进行私有化处理，并要求用户通过我们提供的`set/get`方法进行设置
```php
private $age;
//set方法
function setAge($age){
    $this->age=$age;
} 
//get方法
function getAge(){
     return $this->age;
}
$对象->getAge();
$对象->setAge(12);
```

#### 属性的封装+魔术方法
```php
__get( -> __set(, ->= }
$对象->age; //访问对象私有属性时，自动调用__get()魔术方法，并且将访问的属性名传给__get()方法；
$对象->age=12; //设置对象私有属性时，自动调用__set()魔术方法，并且将设置的属性名以及属性值传给__set()方法；
```
> 注意：在魔术方法中，可以使用分支结构，判断$key的不同，进行不同操作。

#### 关于封装的魔术方法：
- `__set($key,$value)`:给类私有属性赋值时自动调用，调用时给方法传递两个参数：需要设置的属性名，属性值。
- `__get($key,$value)`:读取类私有属性时自动调用，调用时给方法传递一个参数，需要读取的属性名；
- `__isset($key)`:外部使用`isset()`函数检测私有属性时，自动调用。
> 类外部使用isset();检测私有属性，默认是检测不到的。false
所以，我们可以使用__isset();函数，在自动调用时，返回内部检测结果。

- `function __isset($key){return isset($this -> $key);}`
> 当外部使用isset($对象名->私有属性);检测时，将自动调用上述__isset()返回的结果！

- `__unset($key)`:外部使用`unset()`函数删除私有属性时，自动调用；
`function __unset($key){unset($this -> $key);}` 
> 当外部使用unset($对象名->私有属性);删除属性时，自动将属性名传给__unset(),并交由这个魔术方法处理。

## 继承的基础知识：
### 如何实现继承？
给子类使用`extends`关键字，让子类继承父类；
```php
class Student extends Person{}
```

### 现继承的注意事项？
- 子类只能继承父类的非私有属性。
- 子类继承父类后，相当于将父类的属性和方法copy到子类，可以直接使用$this调用。
- PHP只能单继承，不支持一个类继承多个类。但是一个类进行多层继承。
```php
class Person{}
class Adult extends Person{}
class Student extends Adult{} 
//Student 类就同时具有了Adult类和Person类的属性和方法
```
### 方法覆盖(方法重写)
- 子类继承父类
- 子类重写父类已有方法
> 符合上述两个条件，称为方法覆盖。覆盖之后，子类调用方法，将调用子类自己的方法。
同样，除了方法覆盖，子类也可以具有与父类同名的属性，进行属性覆盖。

如果，子类重写了父类方法，如何在子类中调用父类同名方法？

`partent::方法名();`
所以，当子类继承父类时，需在子类的构造中的第一步，首先调用父类构造进行复制。
```php
function __construct($name,$sex,$school){
    partent::__construct($name,$sex);
    $this -> school = $school;
}
```

## PHP关键字
### final
- `final`修饰类，此类为最终类，不能被继承！
- `final`修饰方法，此方法为最终方法，不能被重写！
- `final`不能修饰属性。

### static
- 可以修饰属性和方法，分别称为静态属性和静态方法，也叫类属性，类方法；
- 静态属性，静态方法，只能使用类名直接调用。
> 使用"类名::$静态属性" , "类名::静态方法()"
`Person::$sex; Person::say();`
- 静态属性和方法，在类装载时就会声明，先于对象产生。
- 静态方法中，不能调用非静态属性或方法；
> 非静态方法，可以调用静态属性和方法。 （因为静态属性和方法在类装载时已经产生，而非静态的属性方法，此时还没有实例化诞生）
- 在类中，可以使用`self`关键字，代指本类名。
```php
class Person{
    static $sex = "nan";
    function say(){
        echo self::$sex;
    }
}
```
- 静态属性是共享的，也就是new出很多对象，也是共用一个属性。

### const关键字：
在类中声明常量，不能是`define()`函数！必须使用`const`关键字。与`define()`声明相似，`const`关键字声明常量不能带`$`，必须全部大写！
常量一旦声明，不能改变。调用时与`static`一样，使用类名调用`Person::常量`。

#### instanceof操作符：
检测一个对象，是否是某一个类的实例。（包括爹辈，爷爷辈,太爷爷辈……）
```php
$zhangsan instanceof Person;
```
【小总结】几种特殊操作符：
- `.` 只能连接字符串； `"".""`
- `=>` 声明数组时，关联键与值`["key"=>"value"]`
- `->` 对象(`$this new`出的对象)调用成员属性，成员方法；
- `::` 使用`parent`关键字，调用父类中的同名方法：`parent::say();`,使用类名(和`self`)调用类中的静态属性，静态方法，以及常量。

## 魔术方法小总结
- `__construct()`:构造函数，new一个对象时，自动调用。
- `__destruct()`:析构函数，当一个对象被销毁前，自动调用。
- `__get()`:访问类中私有属性时，自动调用。传递读取的属性名，返回`$this->属性名`
- `__set()`:给类的私有属性赋值时，自动调用。传递需要设置的属性名和属性值；
- `__isset()`:使用`isset()`检测对象私有属性时，自动调用。传递检测的属性名，返回`isset($this -> 属性名);`
- `__unset()`:使用`unset()`删除对象私有属性时，自动调用。传递删除的属性名，方法中执行`unset($this -> 属性名);`
- `__toString(`):使用`echo`打印对象时，自动调用。返回想要在打印对象时，显示的内容；返回必须是字符串；
- `__call()`:调用一个类中未定义或未公开的方法时，自动调用。传递被调用的函数名，和参数列表数组；
- `__clone()`:当使用`clone`关键字，克隆一个对象时，自动调用。作用是为新克隆的对象进行初始化赋值；
- `__sleep()`:对象序列化时，自动调用。返回一个数组，数组中的值就是可以序列化的属性；
- `__wakeup()`:对象反序列化时，自动调用。为反序列化新产生的对象，进行初始化赋值；
- `__autoload()`:需要在类外部声明函数。当实例化一个未声明的类时，自动调用。传递实例化的类名，可以使用类名自动加载对应的类文件。

## 抽象类和抽象方法
- 什么是抽象方法？
没有方法体`{}`的方法，必须使用`abstract`关键字修饰。这样的方法，我们称为抽象方法。
```php
abstract function say(); //抽象方法
```

### 什么是抽象类？
使用`abstract`关键字修饰的类就是抽象类。
```php
abstract class Person{}
```

### 抽象类的注意事项：
- 抽象类可以包含非抽象方法；
- 包含抽象方法的类必须是抽象类，抽象类并不一定必须包含抽象方法；
- 抽象类，不能实例化。（抽象类中可能包含抽象方法，抽象方法没有方法体，实例化调用没有意义）
我们使用抽象类的目的，就是限制实例化！！！
- 子类继承抽象类，那么子类必须重写父类的所有抽象方法，除非，子类也是抽象类。

### 使用抽象类的作用？
- 限制实例化。（抽象类是一个不完整的类，里面的抽象方法没有方法体，所以不能实例化）
- 抽象类为子类的继承提供一种规范，子类继承一个抽象类，则必须包含并且实现抽象类中已定的抽象方法。

## 接口与多态
### 接口

#### 什么是接口？
接口是一种规范，提供了一组实现接口的类所必须实现的方法组合。
接口使用`interface`关键字声明；
```php
interface Inter{}
```
- 接口中的所有方法，必须都是抽象方法。
- 接口中的抽象方法不需要也不能使用`abstract`修饰。
- 接口中不能声明变量，不能有属性，只能使用常量！！！

#### 接口可以继承接口，使用extends关键字！
接口使用extends继承接口，可以实现多继承。
```php
interface int1 extends Inter,Inter2{}
```
#### 类可以实现接口，使用`implements`关键字！
类使用`implements`实现接口，可同时实现多个接口，多个接口间逗号分隔；
```
abstract class Person implements Inter,Inter2{}
```
一个类实现一个或多个接口，那么这个类，必须实现所有接口中的所有抽象方法！
除非，这个类是抽象类。

#### 接口&&抽象类区别
- 声明方式上，接口使用`interface`关键字，抽象类使用`abstract class`。
- 实现/继承方式上，一个类使用`extends`继承抽象类，使用`implements`实现接口。
- 抽象类只能单继承，接口可以多实现。（接口`extends`接口）、多实现（类`implements`接口）
- 抽象类中可以有非抽象方法，接口中只能有抽象方法，不能有费抽象方法。抽象类中的抽象方法必须使用`abstract`关键字修饰，接口中抽象方法不能带修饰词。
- 抽象类是个类，可以有属性、变量；接口中只能有常量。

### 多态
#### 多态
##### 一个类，被多个子类继承。
如果，这个类的某个方法，在多个子类中，表现出不同的功能，我们称这种行为为多态。

##### 实现多态的必要途径：
- 子类继承父类；
- 子类重写父类方法；
- 父类引用指向子类对象